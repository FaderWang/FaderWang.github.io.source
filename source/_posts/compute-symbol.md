---
title: 一问搞懂原码、补码、反码、位移运算
date: 2019-09-24 16:13:26
tags: compute

---

> 众所周知，计算机只能识别0和1。所以一个数在计算机中是用二级制表示的，同时也称为机器数。最高位存放符号位，0代表正数，1代表负数。

<!-- more -->

## 原码、反码、补码

### 原码

原码就是第一位为符号位，后面位数表示数值。

```bash
[+1]原 = 0000 0001
[-1]原 = 1000 0001
```

第一位为符号位，所以这里8位二进制数的取值范围为：

```bash
[1111 1111, 0111 1111]
[-127,127]
```

### 反码

正数的反码是其本身；负数的反码是在其原码的基础上，符号位不变，其它位取反

```bash
[+1] = [0000 0001]原 = [0000 0001]反
[-1] = [1000 0001]原 = [1111 1110]反
```

### 补码

正数的补码是其本身；负数的补码是在其反码的基础上+1

```bash
[+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补
[-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
```

## 为何要使用原码、反码和补码

计算机设计的时候，就要遵循最为简单的原理。对于符号位，人脑可以直观的判断，但是对于计算机而言，想要设计判断符号位的方法就相对复杂了。同时我们也知道，运算中的减法可以转换成加一个负数。



根据以上两种要求，所以尝试让符号位也参与计算同时只保留加法的方法：

```bash
计算 1 - 1 = 0
1 + （-1）= [00000001]原 + [10000001] = [10000010] = -2
```

这里使用原码做减法运算，结果显然不对。为了解决这里的问题，出现了反码。

```bash
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
```

发现用反码计算减法， 结果的真值部分是正确的。而唯一的问题其实就出现在"0"这个特殊的数值上。 虽然人们理解上+0和-0是一样的， 但是0带符号是没有任何意义的， 而且会有[0000 0000]原和[1000 0000]原两个编码表示0。



补码的出现就是为了解决0的符号以及两个编码的问题

```bash
1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
```

这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128。

```bash
(-1) + (-127) = [10000001]原 + [11111111]原 = [11111111]补
+ [10000001]补 = [10000000]补 = [10000000]原
```

-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补 就是-128。 但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原， 这是不正确的)。

使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。 这就是为什么8位二进制， 使用原码或反码表示的范围为[-127, +127]， 而使用补码表示的范围为[-128, 127]。

## 位移

左位移

```bash
-1 << 2
[10000001]原 = [11111111]补 
左移两位 ---> [11111100]补 = [10000100]原 = -4
```

右位移

```bash
-8 >> 2
[10001000]原 = [11111000]补
又移两位 ---> [11111110]补 = [11111101]反 =[00000010]原 = -2 
```

无符号右移

```bash
-8 >>> 2
[10001000]原 = [11111000]补
又移两位 ---> [0011 省略24位1 1110]补 = [00 省略24为1 111110]原码 = 2^30-2 = 1073741822
```

